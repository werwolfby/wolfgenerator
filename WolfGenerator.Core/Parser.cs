using System;
using System.Text;
using System.Collections.Generic;
using WolfGenerator.Core.AST;
using WolfGenerator.Core.Writer;



//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by COCO from Parser.frame.
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Collections;

namespace WolfGenerator.Core {


	public class Parser {
	public const int _EOF = 0;
	public const int _ident = 1;
	public const int _ruleClass = 2;
	public const int _rule = 3;
	public const int _join = 4;
	public const int _apply = 5;
	public const int _call = 6;
	public const int _method = 7;
	public const int _match = 8;
	public const int _uses = 9;
	public const int _endStatement = 10;
	public const int _end = 11;
	public const int _value = 12;
	public const int _code = 13;
	public const int _codeEnd1 = 14;
	public const int _codeEnd2 = 15;
	public const int _from = 16;
	public const int _with = 17;
	public const int _space = 18;
	public const int _clone = 19;
	public const int _dot = 20;
	public const int _comma = 21;
	public const int _openB = 22;
	public const int _closB = 23;
	public const int _openB1 = 24;
	public const int _closB1 = 25;
	public const int _openG = 26;
	public const int _closG = 27;
	public const int _number = 28;
	public const int _string = 29;
	public const int _badString = 30;
	public const int _char = 31;
	public const int _text = 32;
	public const int maxT = 33;

		const bool T = true;
		const bool x = false;
		const int minErrDist = 2;
		
		public Scanner scanner;
		public Errors  errors;

		public Token t;    // last recognized token
		public Token la;   // lookahead token
		int errDist = minErrDist;

public RuleClassStatement ruleClassStatement;
	
	string ExtractString( bool isStart, bool ifEnd, int startPos, int endPos )
	{
		string text = scanner.buffer.GetString( startPos, endPos );
		return ExtractString( isStart, ifEnd, text );
	}
	
	string ExtractString( bool isStart, bool ifEnd, string text )
	{
		int startIndex = 0;
		int endIndex = 0;
		return ExtractString( isStart, ifEnd, text, ref startIndex, ref endIndex );
	}
	
	string ExtractString( bool isStart, bool ifEnd, string text, ref int startIndex, ref int endIndex )
	{
		if (!string.IsNullOrEmpty( text ))
		{
			startIndex = 0;
			endIndex = 0;
			if (isStart)
			{
				if (text.StartsWith( "\r\n" )) startIndex = 2;
				else if (text.StartsWith( "\n" )) startIndex = 1;
			}
			if (ifEnd)
			{
				if (text.EndsWith( "\r\n" )) endIndex = 2;
				else if (text.EndsWith( "\n" )) endIndex = 1;
			}
			if (text.Length - endIndex - startIndex > 0)
			{
				if (startIndex > 0 || endIndex > 0) return text.Substring( startIndex, text.Length - endIndex - startIndex );				
				else return text;
			}
		}
		return "";
	}
	
	int AddStatement( bool isStart, List<RuleStatement> statements, bool ifEnd, Token t )
	{
		int startIndex = 0;
		int endIndex = 0;
		var text = ExtractString( isStart, ifEnd, t.val, ref startIndex, ref endIndex );
		
		if (!string.IsNullOrEmpty( text )) statements.Add( new TextStatement( new StatementPosition( t.pos + startIndex, t.pos + text.Length - 1 + startIndex ), text ) );
		return la.pos;
	}


		public Parser(Scanner scanner) {
			this.scanner = scanner;
			errors = new Errors(scanner);
		}

		public Parser(System.IO.Stream str) {
			scanner = new Scanner(str);
			errors = new Errors(scanner);
		}
		
		public Parser(string source) {
			MemoryStream memIn = new MemoryStream();
			byte[] b=System.Text.Encoding.ASCII.GetBytes(source);
			memIn.Write(b,0,b.Length);
			memIn.Seek(0,0);
			this.scanner = new Scanner(memIn);
			errors = new Errors(scanner);
		}

		void SynErr (int n) {
			if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
			errDist = 0;
		}

		public void SemErr (string msg) {
			if (errDist >= minErrDist) errors.Error(t.line, t.col, msg);
			errDist = 0;
		}
		
		void Get () {
			for (;;) {
				t = la;
				la = scanner.Scan();
				if (la.kind <= maxT) { ++errDist; break; }

				la = t;
			}
		}
		
		void Expect (int n) {
			if (la.kind==n) Get(); else { SynErr(n); }
		}
		
		bool StartOf (int s) {
			return set[s, la.kind];
		}
		
		void ExpectWeak (int n, int follow) {
			if (la.kind == n) Get();
			else {
				SynErr(n);
				while (!StartOf(follow)) Get();
			}
		}
		
		bool WeakSeparator (int n, int syFol, int repFol) {
			bool[] s = new bool[maxT+1];
			if (la.kind == n) { Get(); return true; }
			else if (StartOf(repFol)) return false;
			else {
				for (int i=0; i <= maxT; i++) {
					s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
				}
				SynErr(n);
				while (!s[la.kind]) Get();
				return StartOf(syFol);
			}
		}
		
	void WolfGenerator() {
		List<UsingStatement> usingStatementList = null; 
		List<RuleClassMethodStatement> ruleMethodStatementList = null; 
		string name; 
		Expect(2);
		Token start = t; 
		Expect(1);
		name = t.val; 
		Expect(10);
		while (la.kind == 9) {
			UsingStatement usingStatement; 
			Using(out usingStatement);
			if (usingStatementList == null) usingStatementList = new List<UsingStatement>();
			usingStatementList.Add( usingStatement ); 
		}
		while (la.kind == 3 || la.kind == 7 || la.kind == 8) {
			if (la.kind == 3 || la.kind == 8) {
				RuleMethodStatement ruleMethod; 
				RuleMethod(out ruleMethod);
				if (ruleMethodStatementList == null) 
				   ruleMethodStatementList = new List<RuleClassMethodStatement>();
				ruleMethodStatementList.Add( ruleMethod ); 
			} else {
				MethodStatement method; 
				Method(out method);
				if (ruleMethodStatementList == null) 
				   ruleMethodStatementList = new List<RuleClassMethodStatement>();
				ruleMethodStatementList.Add( method ); 
			}
		}
		while (!(la.kind == 0 || la.kind == 11)) {SynErr(34); Get();}
		ExpectWeak(11, 1);
		ruleClassStatement = new RuleClassStatement( new StatementPosition( start, t ), name, usingStatementList, ruleMethodStatementList ); 
	}

	void Using(out UsingStatement usingStatement) {
		List<string> namespaceList = new List<string>(); 
		Expect(9);
		Token start = t; 
		Expect(1);
		namespaceList.Add( t.val ); 
		while (la.kind == 20) {
			Get();
			Expect(1);
			namespaceList.Add( t.val ); 
		}
		string namespaceName = string.Join( ".", namespaceList.ToArray() );
		usingStatement = new UsingStatement( new StatementPosition( start, t ), namespaceName ); 
		Expect(10);
	}

	void RuleMethod(out RuleMethodStatement statement) {
		string methodName; IList<Variable> variables;
		List<Variable> variableList;
		List<RuleStatement> statements = new List<RuleStatement>();
		bool isStart = true;
		ValueStatement valueStatement;
		JoinStatement joinStatement;
		CodeStatement codeStatement;
		CallStatement callStatement;
		MatchMethodStatement matchStatement = null; 
		Token start = la; 
		if (la.kind == 8) {
			MatchMethod(out matchStatement);
		}
		while (!(la.kind == 0 || la.kind == 3)) {SynErr(35); Get();}
		Expect(3);
		Expect(1);
		methodName = t.val; 
		Expect(22);
		Variables(out variableList);
		ExpectWeak(23, 1);
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(36); Get();}
		Expect(10);
		variables = variableList == null ? null : variableList.AsReadOnly(); 
		while (StartOf(2)) {
			if (la.kind == 32) {
				Get();
				AddStatement( isStart, statements, la.kind == _end, t ); 
			} else if (la.kind == 12) {
				Value(out valueStatement);
				statements.Add( valueStatement ); isStart = false; 
			} else if (la.kind == 4) {
				Join(out joinStatement);
				statements.Add( joinStatement ); isStart = false; 
			} else if (la.kind == 13) {
				isStart = false; 
				Code(out codeStatement, ref isStart);
				statements.Add( codeStatement ); 
			} else {
				Call(out callStatement);
				statements.Add( callStatement ); isStart = false; 
			}
		}
		while (!(la.kind == 0 || la.kind == 11)) {SynErr(37); Get();}
		Expect(11);
		statement = new RuleMethodStatement( new StatementPosition( start, t ), matchStatement, methodName, variables, statements ); 
	}

	void Method(out MethodStatement methodStatement) {
		WolfGenerator.Core.AST.Type returnType;
		List<Variable> variables = null;
		int startPos = -1; string name; 
		while (!(la.kind == 0 || la.kind == 7)) {SynErr(38); Get();}
		Expect(7);
		Token start = t; 
		Type(out returnType);
		Expect(1);
		name = t.val; 
		Expect(22);
		Variables(out variables);
		ExpectWeak(23, 1);
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(39); Get();}
		Expect(10);
		startPos = t.pos + t.val.Length; 
		while (StartOf(3)) {
			Get();
		}
		while (!(la.kind == 0 || la.kind == 11)) {SynErr(40); Get();}
		Expect(11);
		methodStatement = new MethodStatement( new StatementPosition( start, t ), returnType, name, variables, ExtractString( true, false, startPos, t.pos ) ); 
	}

	void MatchMethod(out MatchMethodStatement statement) {
		string name; string code; 
		Expect(8);
		Token start = t; 
		Expect(1);
		name = t.val; 
		Expect(10);
		int startPos = t.pos + t.val.Length; 
		while (StartOf(3)) {
			Get();
		}
		code = ExtractString( true, true, startPos, la.pos ); 
		Expect(11);
		statement = new MatchMethodStatement( new StatementPosition( start, t ), name, code ); 
	}

	void Variables(out List<Variable> variableList ) {
		variableList = null; Variable var; 
		if (la.kind == 1) {
			Var(out var);
			if (variableList == null) variableList = new List<Variable>();
			variableList.Add( var ); 
			while (WeakSeparator(21,4,5) ) {
				Var(out var);
				variableList.Add( var ); 
			}
		}
	}

	void Value(out ValueStatement valueStatement) {
		while (!(la.kind == 0 || la.kind == 12)) {SynErr(41); Get();}
		Expect(12);
		Token start = t; int pos = t.pos + t.val.Length; 
		while (StartOf(6)) {
			Get();
		}
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(42); Get();}
		Expect(10);
		int endPos = t.pos;
		string value = scanner.buffer.GetString( pos, endPos );
		valueStatement = new ValueStatement( new StatementPosition( start, t ), value.Trim() );  
	}

	void Join(out JoinStatement joinStatement) {
		string @string;
		List<RuleStatement> statements = null;
		ValueStatement valueStatement;
		ApplyStatement applyStatement;
		CallStatement callStatement; 
		//JoinStatement joinStatement; 
		AppendType appendType = AppendType.EmptyLastLine; 
		while (!(la.kind == 0 || la.kind == 4)) {SynErr(43); Get();}
		Expect(4);
		Token start = t; 
		Expect(29);
		@string = t.val.Substring( 1, t.val.Length - 2 ); 
		if (la.kind == 17) {
			Get();
			if (la.kind == 18) {
				Get();
				appendType = AppendType.SpaceLastLine; 
			} else if (la.kind == 19) {
				Get();
				appendType = AppendType.CloneLastLine; 
			} else if (StartOf(7)) {
				while (StartOf(8)) {
					Get();
				}
				
			} else SynErr(44);
		}
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(45); Get();}
		Expect(10);
		while (la.kind == 5 || la.kind == 6 || la.kind == 12) {
			if (la.kind == 12) {
				Value(out valueStatement);
				if (statements == null) statements = new List<RuleStatement>();
				statements.Add( valueStatement ); 
			} else if (la.kind == 5) {
				Apply(out applyStatement);
				if (statements == null) statements = new List<RuleStatement>();
				statements.Add( applyStatement ); 
			} else {
				Call(out callStatement);
				if (statements == null) statements = new List<RuleStatement>();
				statements.Add( callStatement ); 
			}
		}
		while (!(la.kind == 0 || la.kind == 11)) {SynErr(46); Get();}
		Expect(11);
		joinStatement = new JoinStatement( new StatementPosition( start, t ), @string, appendType, statements ); 
	}

	void Code(out CodeStatement codeStatement, ref bool isStart) {
		while (!(la.kind == 0 || la.kind == 13)) {SynErr(47); Get();}
		Expect(13);
		Token start = t; int startPos = t.pos + t.val.Length; 
		while (StartOf(9)) {
			Get();
		}
		string value = scanner.buffer.GetString( startPos, la.pos ); 
		if (la.kind == 14) {
			ExpectWeak(14, 10);
		} else if (la.kind == 15) {
			ExpectWeak(15, 10);
			isStart = true; 
		} else SynErr(48);
		codeStatement = new CodeStatement( new StatementPosition( start, t ), value.Trim() ); 
	}

	void Call(out CallStatement callStatement) {
		string methodName; string parameters = null; 
		while (!(la.kind == 0 || la.kind == 6)) {SynErr(49); Get();}
		Expect(6);
		Token start = t; 
		Expect(1);
		methodName = t.val; 
		int startPos = -1; int endPos = -1; 
		if (la.kind == 24) {
			Get();
			startPos = t.pos + t.val.Length; 
			while (StartOf(11)) {
				Get();
			}
			endPos = la.pos; 
			Expect(25);
		} else if (la.kind == 22) {
			Get();
			startPos = t.pos + t.val.Length; 
			while (StartOf(12)) {
				Get();
			}
			endPos = la.pos; 
			Expect(23);
		} else SynErr(50);
		if (startPos > 0 && endPos > 0)
		   parameters = scanner.buffer.GetString( startPos, endPos ).Trim(); 
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(51); Get();}
		Expect(10);
		callStatement = new CallStatement( new StatementPosition( start, t ), methodName, parameters ); 
	}

	void Type(out WolfGenerator.Core.AST.Type type) {
		StringBuilder name = new StringBuilder(); 
		List<WolfGenerator.Core.AST.Type> genericParameters = null; 
		Expect(1);
		Token start = t; name.Append( t.val ); 
		while (la.kind == 20) {
			Get();
			Expect(1);
			name.Append( '.' ); name.Append( t.val ); 
		}
		if (la.kind == 26) {
			genericParameters = new List<WolfGenerator.Core.AST.Type>();
			WolfGenerator.Core.AST.Type generic; 
			Get();
			Type(out generic);
			genericParameters.Add( generic ); 
			while (WeakSeparator(21,4,13) ) {
				Type(out generic);
				genericParameters.Add( generic ); 
			}
			Expect(27);
		}
		type = new WolfGenerator.Core.AST.Type( new StatementPosition( start, t ), name.ToString(), genericParameters ); 
	}

	void Var(out Variable var) {
		WolfGenerator.Core.AST.Type type; Token start = t; 
		Type(out type);
		Expect(1);
		var = new Variable( new StatementPosition( start, t ), t.val, type ); 
	}

	void Apply(out ApplyStatement applyStatement) {
		string methodName; string parameters = null; string from; 
		while (!(la.kind == 0 || la.kind == 5)) {SynErr(52); Get();}
		Expect(5);
		Token start = t; 
		Expect(1);
		methodName = t.val; 
		int startPos = -1; int endPos = -1; 
		if (la.kind == 24) {
			Get();
			startPos = t.pos + t.val.Length; 
			while (StartOf(11)) {
				Get();
			}
			endPos = la.pos; 
			Expect(25);
		} else if (la.kind == 22) {
			Get();
			startPos = t.pos + t.val.Length; 
			while (StartOf(12)) {
				Get();
			}
			endPos = la.pos; 
			Expect(23);
		} else SynErr(53);
		if (startPos > 0 && endPos > 0)
		   parameters = scanner.buffer.GetString( startPos, endPos ).Trim(); 
		while (!(la.kind == 0 || la.kind == 16)) {SynErr(54); Get();}
		Expect(16);
		int startFrom = la.pos; 
		while (StartOf(6)) {
			Get();
		}
		from = scanner.buffer.GetString( startFrom, la.pos ).Trim(); 
		while (!(la.kind == 0 || la.kind == 10)) {SynErr(55); Get();}
		Expect(10);
		applyStatement = new ApplyStatement( new StatementPosition( start, t ), methodName, parameters, from ); 
	}



		public void InitParse()
		{
			la = new Token();
			la.val = "";		
			Get();
		}
		
		public void Parse() {
			InitParse();
		WolfGenerator();
		Expect(0);

		Expect(0);
		}
		
		bool[,] set = {
		{T,x,x,T, T,T,T,T, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{T,x,x,T, T,T,T,T, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, T,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x},
		{x,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
		{x,T,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,T,x,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,x,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
		{T,x,x,T, T,T,T,T, x,x,T,T, T,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x}

		};
	} // end Parser


	public class ErrorData
	{
		public string message;
		public int line;
		public int column;
	}

	public class Errors {
		public int count = 0;                                    // number of errors detected
		public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
		private Scanner scanner;
		private List<ErrorData> errorDatas = new List<ErrorData>();

		public Errors(Scanner scanner)
		{
			this.scanner=scanner;
			
			this.ErrorDatas = errorDatas.AsReadOnly();
		}
		
		public IList<ErrorData> ErrorDatas { get; private set; }
		
		public void SynErr (int line, int col, int n) {
			string s;
			switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "ruleClass expected"; break;
			case 3: s = "rule expected"; break;
			case 4: s = "join expected"; break;
			case 5: s = "apply expected"; break;
			case 6: s = "call expected"; break;
			case 7: s = "method expected"; break;
			case 8: s = "match expected"; break;
			case 9: s = "uses expected"; break;
			case 10: s = "endStatement expected"; break;
			case 11: s = "end expected"; break;
			case 12: s = "value expected"; break;
			case 13: s = "code expected"; break;
			case 14: s = "codeEnd1 expected"; break;
			case 15: s = "codeEnd2 expected"; break;
			case 16: s = "from expected"; break;
			case 17: s = "with expected"; break;
			case 18: s = "space expected"; break;
			case 19: s = "clone expected"; break;
			case 20: s = "dot expected"; break;
			case 21: s = "comma expected"; break;
			case 22: s = "openB expected"; break;
			case 23: s = "closB expected"; break;
			case 24: s = "openB1 expected"; break;
			case 25: s = "closB1 expected"; break;
			case 26: s = "openG expected"; break;
			case 27: s = "closG expected"; break;
			case 28: s = "number expected"; break;
			case 29: s = "string expected"; break;
			case 30: s = "badString expected"; break;
			case 31: s = "char expected"; break;
			case 32: s = "text expected"; break;
			case 33: s = "??? expected"; break;
			case 34: s = "this symbol not expected in WolfGenerator"; break;
			case 35: s = "this symbol not expected in RuleMethod"; break;
			case 36: s = "this symbol not expected in RuleMethod"; break;
			case 37: s = "this symbol not expected in RuleMethod"; break;
			case 38: s = "this symbol not expected in Method"; break;
			case 39: s = "this symbol not expected in Method"; break;
			case 40: s = "this symbol not expected in Method"; break;
			case 41: s = "this symbol not expected in Value"; break;
			case 42: s = "this symbol not expected in Value"; break;
			case 43: s = "this symbol not expected in Join"; break;
			case 44: s = "invalid Join"; break;
			case 45: s = "this symbol not expected in Join"; break;
			case 46: s = "this symbol not expected in Join"; break;
			case 47: s = "this symbol not expected in Code"; break;
			case 48: s = "invalid Code"; break;
			case 49: s = "this symbol not expected in Call"; break;
			case 50: s = "invalid Call"; break;
			case 51: s = "this symbol not expected in Call"; break;
			case 52: s = "this symbol not expected in Apply"; break;
			case 53: s = "invalid Apply"; break;
			case 54: s = "this symbol not expected in Apply"; break;
			case 55: s = "this symbol not expected in Apply"; break;

				default: s = "error " + n; break;
			}
			Error(line, col, s);
		}

		public virtual void Error (int lin, int col, string err) 
		{
			errorDatas.Add( new ErrorData { message = err, line = lin, column = col } );
		
			scanner.WriteError(errMsgFormat,scanner.srcFile,lin,col,err);
			count++;
		}

	} // Errors

}